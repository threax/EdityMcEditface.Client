/* tslint: disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v6.21.6150.29665 (NJsonSchema v5.12.6149.949) (http://NSwag.org)
// </auto-generated>
//----------------------

export class CompileClient {
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * Get the current status of the compiler.
     * @return Success
     */
    status(bearer: string): Promise<CompilerStatus> {
        let url_ = this.baseUrl + "/edity/Compile/Status";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processStatus(response);
        });
    }

    private processStatus(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: CompilerStatus = null;
                result200 = data === "" ? null : <CompilerStatus>JSON.parse(data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Run the compiler.
     * @return Success
     */
    compile(bearer: string): Promise<CompilerResult> {
        let url_ = this.baseUrl + "/edity/Compile/Compile";

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processCompile(response);
        });
    }

    private processCompile(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: CompilerResult = null;
                result200 = data === "" ? null : <CompilerResult>JSON.parse(data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export class GitClient {
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * Get the uncommitted changes.
     * @return Success
     */
    uncommittedChanges(bearer: string): Promise<UncommittedChange[]> {
        let url_ = this.baseUrl + "/edity/Git/UncommittedChanges";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processUncommittedChanges(response);
        });
    }

    private processUncommittedChanges(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: UncommittedChange[] = null;
                result200 = data === "" ? null : <UncommittedChange[]>JSON.parse(data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get the files that need to be synced.
     * @return Success
     */
    syncInfo(bearer: string): Promise<SyncInfo> {
        let url_ = this.baseUrl + "/edity/Git/SyncInfo";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processSyncInfo(response);
        });
    }

    private processSyncInfo(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: SyncInfo = null;
                result200 = data === "" ? null : <SyncInfo>JSON.parse(data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get the diff of the file between its original and modified version.
     * @file The file to get a diff for.
     * @return Success
     */
    uncommittedDiff(file: string, bearer: string): Promise<DiffInfo> {
        let url_ = this.baseUrl + "/edity/Git/UncommittedDiff/{file}";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processUncommittedDiff(response);
        });
    }

    private processUncommittedDiff(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: DiffInfo = null;
                result200 = data === "" ? null : <DiffInfo>JSON.parse(data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get the history of the entire repo.
     * @page The page to lookup, defaults to 0.
     * @count The number of pages to return, defaults to 25.
     * @return Success
     */
    repoHistory(page: number, count: number, bearer: string): Promise<History[]> {
        let url_ = this.baseUrl + "/edity/Git/RepoHistory?";

        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processRepoHistory(response);
        });
    }

    private processRepoHistory(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: History[] = null;
                result200 = data === "" ? null : <History[]>JSON.parse(data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get the number of history entries for the entire repo.
     * @file The file to lookup.
     * @return Success
     */
    repoHistoryCount(file: string, bearer: string): Promise<number> {
        let url_ = this.baseUrl + "/edity/Git/RepoHistoryCount/{file}";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processRepoHistoryCount(response);
        });
    }

    private processRepoHistoryCount(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: number = null;
                result200 = data === "" ? null : <number>JSON.parse(data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * The conflicts in the current working directory.
     * @return Success
     */
    conflicts(bearer: string): Promise<ConflictInfo[]> {
        let url_ = this.baseUrl + "/edity/Git/Conflicts";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processConflicts(response);
        });
    }

    private processConflicts(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: ConflictInfo[] = null;
                result200 = data === "" ? null : <ConflictInfo[]>JSON.parse(data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get the info for a merge for a file.
     * @return Success
     */
    mergeInfo(file: string, bearer: string): Promise<MergeInfo> {
        let url_ = this.baseUrl + "/edity/Git/MergeInfo/{file}";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processMergeInfo(response);
        });
    }

    private processMergeInfo(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: MergeInfo = null;
                result200 = data === "" ? null : <MergeInfo>JSON.parse(data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Ge the history of a file.
     * @file The file to lookup.
     * @page The page to lookup, defaults to 0.
     * @count The number of pages to return, defaults to 25.
     * @return Success
     */
    fileHistory(file: string, page: number, count: number, bearer: string): Promise<History[]> {
        let url_ = this.baseUrl + "/edity/Git/FileHistory/{file}?";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processFileHistory(response);
        });
    }

    private processFileHistory(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: History[] = null;
                result200 = data === "" ? null : <History[]>JSON.parse(data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get a particluar file version.
     * @sha The sha to lookup.
     * @file The file.
     * @return Success
     */
    fileVersion(sha: string, file: string, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Git/FileVersion/{sha}/{file}";

        if (sha === undefined || sha === null)
            throw new Error("The parameter 'sha' must be defined.");
        url_ = url_.replace("{sha}", encodeURIComponent("" + sha));
        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processFileVersion(response);
        });
    }

    private processFileVersion(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Commit the current working directory.
     * @newCommit The new commit object.
     * @return Success
     */
    commit(newCommit: NewCommit, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Git/Commit";

        const content_ = JSON.stringify(newCommit);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processCommit(response);
        });
    }

    private processCommit(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Pull in changes from the origin repo.
     * @return Success
     */
    pull(bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Git/Pull";

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPull(response);
        });
    }

    private processPull(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Push changes to the origin repo.
     * @return Success
     */
    push(bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Git/Push";

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPush(response);
        });
    }

    private processPush(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Resolve the conflicts on the file.
     * @file The file to resolve.
     * @return Success
     */
    resolve(file: string, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Git/Resolve/{file}";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processResolve(response);
        });
    }

    private processResolve(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Revert a file to its unmodified version.
     * @file The file to revert.
     * @return Success
     */
    revert(file: string, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Git/Revert/{file}";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processRevert(response);
        });
    }

    private processRevert(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export class PageClient {
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * Get the current page settings.
     * @file The name of the file to lookup.
     * @return Success
     */
    getSettings(file: string, bearer: string): Promise<PageSettings> {
        let url_ = this.baseUrl + "/edity/Page/GetSettings/{file}";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetSettings(response);
        });
    }

    private processGetSettings(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: PageSettings = null;
                result200 = data === "" ? null : <PageSettings>JSON.parse(data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Update the settings for the page.
     * @file The file who's pages to upload.
     * @settings The page settings to set.
     * @return Success
     */
    updateSettings(file: string, settings: PageSettings, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Page/UpdateSettings/{file}";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        const content_ = JSON.stringify(settings);
        return this.http.fetch(url_, {
            body: content_,
            method: "PUT",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processUpdateSettings(response);
        });
    }

    private processUpdateSettings(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "400") {
                    let result400: ModelStateErrorResult = null;
                    result400 = data === "" ? null : <ModelStateErrorResult>JSON.parse(data, this.jsonParseReviver);
                    throw result400;
                }
                else
                    if (status === "500") {
                        let result500: ExceptionResult = null;
                        result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                        throw result500;
                    }
                    else {
                        throw new Error("error_no_callback_for_the_received_http_status");
                    }
        });
    }

    /**
     * Save a page.
     * @file The file to save.
     * @return Success
     */
    save(file: string, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Page/Save/{file}";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "PUT",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processSave(response);
        });
    }

    private processSave(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Delete a page.
     * @file The name of the page to delete.
     * @return Success
     */
    delete(file: string, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Page/Delete/{file}";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "DELETE",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processDelete(response);
        });
    }

    private processDelete(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Add an asset to a page.
     * @file The page to add the asset to.
     * @return Success
     */
    addAsset(file: string, bearer: string): Promise<ImageUploadResponse> {
        let url_ = this.baseUrl + "/edity/Page/AddAsset/{file}";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processAddAsset(response);
        });
    }

    private processAddAsset(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: ImageUploadResponse = null;
                result200 = data === "" ? null : <ImageUploadResponse>JSON.parse(data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export class ShutdownClient {
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * Stop the Edity McEditface process.
     * @return Success
     */
    shutdown(bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Shutdown/Shutdown";

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processShutdown(response);
        });
    }

    private processShutdown(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export class TemplateClient {
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * Get all the templates in the system.
     * @return Success
     */
    listAll(bearer: string): Promise<Template[]> {
        let url_ = this.baseUrl + "/edity/Template/ListAll";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processListAll(response);
        });
    }

    private processListAll(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: Template[] = null;
                result200 = data === "" ? null : <Template[]>JSON.parse(data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get a single template's content.
     * @return Success
     */
    getContent(file: string, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Template/GetContent/{file}";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetContent(response);
        });
    }

    private processGetContent(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export class UploadClient {
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : window;
    }

    /**
     * List the files in dir.
     * @dir The directory to list the files under.
     * @return Success
     */
    listFiles(dir: string, file: string, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Upload/ListFiles/{file}?";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        if (dir !== undefined)
            url_ += "dir=" + encodeURIComponent("" + dir) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processListFiles(response);
        });
    }

    private processListFiles(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Uplaod a new file.
     * @file The file name of the uploaded file.
     * @return Success
     */
    upload(file: string, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Upload/Upload/{file}";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processUpload(response);
        });
    }

    private processUpload(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Delete a file.
     * @file The file to delete.
     * @return Success
     */
    delete(file: string, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Upload/Delete/{file}";

        if (file === undefined || file === null)
            throw new Error("The parameter 'file' must be defined.");
        url_ = url_.replace("{file}", encodeURIComponent("" + file));

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "DELETE",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processDelete(response);
        });
    }

    private processDelete(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>JSON.parse(data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export interface CompilerStatus {
    readonly behindBy: number;
    readonly behindHistory: any;
}

export interface ExceptionResult {
    exception: any;
    message: string;
}

export interface CompilerResult {
    elapsedSeconds: number;
}

export interface UncommittedChange {
    readonly filePath: string;
    readonly state: UncommittedChangeState;
}

export interface SyncInfo {
    aheadBy: number;
    behindBy: number;
    aheadHistory: History[];
    behindHistory: History[];
    hasUncomittedChanges: boolean;
}

export interface History {
    readonly message: string;
    readonly sha: string;
    readonly name: string;
    readonly email: string;
    readonly when: Date;
}

export interface DiffInfo {
    original: string;
    changed: string;
}

export interface ConflictInfo {
    readonly filePath: string;
}

export interface MergeInfo {
    merged: string;
    theirs: string;
    mine: string;
}

export interface NewCommit {
    message: string;
}

export interface PageSettings {
    title: string;
}

export interface ModelStateErrorResult {
    errors: { [key: string]: string; };
    message: string;
}

export interface ImageUploadResponse {
    /** Set to 1 for uploaded or 0 for not uploaded */
    uploaded: number;
    /** The name of the saved file */
    fileName: string;
    /** The url to the saved file */
    url: string;
    /** A message to display */
    message: string;
}

export interface Template {
    path: string;
}

export enum UncommittedChangeState {
    Nonexistent = <any>"Nonexistent",
    Unaltered = <any>"Unaltered",
    Added = <any>"Added",
    Removed = <any>"Removed",
    Renamed = <any>"Renamed",
    Modified = <any>"Modified",
    Unreadable = <any>"Unreadable",
    Ignored = <any>"Ignored",
    Conflicted = <any>"Conflicted",
}