/* tslint: disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v7.0.6156.27159 (NJsonSchema v5.16.6156.29215) (http://NSwag.org)
// </auto-generated>
//----------------------

import { Fetcher, RequestInfo, RequestInit, Response } from 'hr.Fetcher';
import * as di from 'hr.di';
import { IBaseUrlInjector } from 'edity.editorcore.BaseUrlInjector';

export class TemplateClient {
    private static jsonMimeType = "application/json";
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    parseResult<T>(response: Response, data: string, jsonParseReviver: (key: string, value: any) => any): T | string {
        var result: T | string;
        var contentHeader = response.headers.get('content-type');
        if (contentHeader && contentHeader.length >= TemplateClient.jsonMimeType.length && contentHeader.substring(0, TemplateClient.jsonMimeType.length) === TemplateClient.jsonMimeType) {
            result = data === "" ? null : <T>JSON.parse(data, jsonParseReviver);
        }
        else {
            result = data === "" ? null : data;
        }
        return result;
    }

    /**
     * Get all the templates in the system.
     * @return Success
     */
    listAll(bearer: string): Promise<Template[]> {
        let url_ = this.baseUrl + "/edity/Template/ListAll";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processListAll(response);
        });
    }

    private processListAll(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: Template[] = null;
                result200 = data === "" ? null : <Template[]>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get a single template's content.
     * @return Success
     */
    getContent(file: string, bearer: string): Promise<any> {
        let url_ = this.baseUrl + "/edity/Template/GetContent?";

        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetContent(response);
        });
    }

    private processGetContent(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: any = null;
                result200 = data === "" ? null : <any>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export class UploadClient {
    private static jsonMimeType = "application/json";
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    parseResult<T>(response: Response, data: string, jsonParseReviver: (key: string, value: any) => any): T | string {
        var result: T | string;
        var contentHeader = response.headers.get('content-type');
        if (contentHeader && contentHeader.length >= UploadClient.jsonMimeType.length && contentHeader.substring(0, UploadClient.jsonMimeType.length) === UploadClient.jsonMimeType) {
            result = data === "" ? null : <T>JSON.parse(data, jsonParseReviver);
        }
        else {
            result = data === "" ? null : data;
        }
        return result;
    }

    /**
     * List the files in dir.
     * @dir The directory to list the files under.
     * @return Success
     */
    listFiles(dir: string, bearer: string): Promise<FileList> {
        let url_ = this.baseUrl + "/edity/Upload/ListFiles?";

        if (dir !== undefined)
            url_ += "dir=" + encodeURIComponent("" + dir) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processListFiles(response);
        });
    }

    private processListFiles(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: FileList = null;
                result200 = data === "" ? null : <FileList>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Uplaod a new file.
     * @file The file name of the uploaded file.
     * @return Success
     */
    upload(file: string, content: FileParameter, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Upload/Upload?";

        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        const content_ = new FormData();
        if (content !== null)
            content_.append("content", content.data, content.fileName ? content.fileName : "content");
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
            }
        }).then((response) => {
            return this.processUpload(response);
        });
    }

    private processUpload(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Delete a file.
     * @file The file to delete.
     * @return Success
     */
    delete(file: string, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Upload/Delete?";

        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "DELETE",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processDelete(response);
        });
    }

    private processDelete(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export interface CompilerStatus {
    readonly behindBy: number;
    readonly behindHistory: any;
}

export interface ExceptionResult {
    exception: any;
    message: string;
}

export interface CompilerResult {
    elapsedSeconds: number;
}

export interface UncommittedChange {
    readonly filePath: string;
    readonly state: UncommittedChangeState;
}

export interface SyncInfo {
    aheadBy: number;
    behindBy: number;
    aheadHistory: History[];
    behindHistory: History[];
    hasUncomittedChanges: boolean;
}

export interface History {
    readonly message: string;
    readonly sha: string;
    readonly name: string;
    readonly email: string;
    readonly when: Date;
}

export interface DiffInfo {
    original: string;
    changed: string;
}

export interface ConflictInfo {
    readonly filePath: string;
}

export interface MergeInfo {
    merged: string;
    theirs: string;
    mine: string;
}

export interface NewCommit {
    message: string;
}

export interface PageSettings {
    title: string;
}

export interface ModelStateErrorResult {
    errors: { [key: string]: string; };
    message: string;
}

export interface ImageUploadResponse {
    /** Set to 1 for uploaded or 0 for not uploaded */
    uploaded: number;
    /** The name of the saved file */
    fileName: string;
    /** The url to the saved file */
    url: string;
    /** A message to display */
    message: string;
}

export interface Template {
    path: string;
}

/** A list of files in a directory. */
export interface FileList {
    /** The directories inside this directory. */
    directories: string[];
    /** The files inside this directory. */
    files: string[];
    /** The path that this file list represents. */
    path: string;
}

export enum UncommittedChangeState {
    Nonexistent = <any>"Nonexistent",
    Unaltered = <any>"Unaltered",
    Added = <any>"Added",
    Removed = <any>"Removed",
    Renamed = <any>"Renamed",
    Modified = <any>"Modified",
    Unreadable = <any>"Unreadable",
    Ignored = <any>"Ignored",
    Conflicted = <any>"Conflicted",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

/**
 * Add services. You will need to supply a Fetcher instance to the services yourself.
 */
export function addServices(services: di.ServiceCollection){
    services.tryAddShared(UploadClient, s => {
        var fetcher = s.getRequiredService(Fetcher);
        var shim = s.getRequiredService(IBaseUrlInjector);
        return new UploadClient(shim.BaseUrl, fetcher);
    });
}