/* tslint: disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v7.0.6156.27159 (NJsonSchema v5.16.6156.29215) (http://NSwag.org)
// </auto-generated>
//----------------------

import { Fetcher, RequestInfo, RequestInit, Response } from 'hr.Fetcher';
import * as di from 'hr.di';
import { IBaseUrlInjector } from 'edity.editorcore.BaseUrlInjector';

export class CompileClient {
    private static jsonMimeType = "application/json";
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    parseResult<T>(response: Response, data: string, jsonParseReviver: (key: string, value: any) => any): T | string {
        var result: T | string;
        var contentHeader = response.headers.get('content-type');
        if (contentHeader && contentHeader.length >= CompileClient.jsonMimeType.length && contentHeader.substring(0, CompileClient.jsonMimeType.length) === CompileClient.jsonMimeType) {
            result = data === "" ? null : <T>JSON.parse(data, jsonParseReviver);
        }
        else {
            result = data === "" ? null : data;
        }
        return result;
    }

    /**
     * Get the current status of the compiler.
     * @return Success
     */
    status(bearer: string): Promise<CompilerStatus> {
        let url_ = this.baseUrl + "/edity/Compile/Status";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processStatus(response);
        });
    }

    private processStatus(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: CompilerStatus = null;
                result200 = data === "" ? null : <CompilerStatus>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Run the compiler.
     * @return Success
     */
    compile(bearer: string): Promise<CompilerResult> {
        let url_ = this.baseUrl + "/edity/Compile/Compile";

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processCompile(response);
        });
    }

    private processCompile(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: CompilerResult = null;
                result200 = data === "" ? null : <CompilerResult>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export class GitClient {
    private static jsonMimeType = "application/json";
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    parseResult<T>(response: Response, data: string, jsonParseReviver: (key: string, value: any) => any): T | string {
        var result: T | string;
        var contentHeader = response.headers.get('content-type');
        if (contentHeader && contentHeader.length >= GitClient.jsonMimeType.length && contentHeader.substring(0, GitClient.jsonMimeType.length) === GitClient.jsonMimeType) {
            result = data === "" ? null : <T>JSON.parse(data, jsonParseReviver);
        }
        else {
            result = data === "" ? null : data;
        }
        return result;
    }

    /**
     * Get the uncommitted changes.
     * @return Success
     */
    uncommittedChanges(bearer: string): Promise<UncommittedChange[]> {
        let url_ = this.baseUrl + "/edity/Git/UncommittedChanges";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processUncommittedChanges(response);
        });
    }

    private processUncommittedChanges(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: UncommittedChange[] = null;
                result200 = data === "" ? null : <UncommittedChange[]>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get the files that need to be synced.
     * @return Success
     */
    syncInfo(bearer: string): Promise<SyncInfo> {
        let url_ = this.baseUrl + "/edity/Git/SyncInfo";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processSyncInfo(response);
        });
    }

    private processSyncInfo(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: SyncInfo = null;
                result200 = data === "" ? null : <SyncInfo>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get the diff of the file between its original and modified version.
     * @file The file to get a diff for.
     * @return Success
     */
    uncommittedDiff(file: string, bearer: string): Promise<DiffInfo> {
        let url_ = this.baseUrl + "/edity/Git/UncommittedDiff?";

        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processUncommittedDiff(response);
        });
    }

    private processUncommittedDiff(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: DiffInfo = null;
                result200 = data === "" ? null : <DiffInfo>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get the history of the entire repo.
     * @page The page to lookup, defaults to 0.
     * @count The number of pages to return, defaults to 25.
     * @return Success
     */
    repoHistory(page: number, count: number, bearer: string): Promise<History[]> {
        let url_ = this.baseUrl + "/edity/Git/RepoHistory?";

        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processRepoHistory(response);
        });
    }

    private processRepoHistory(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: History[] = null;
                result200 = data === "" ? null : <History[]>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get the number of history entries for the entire repo.
     * @file The file to lookup.
     * @return Success
     */
    repoHistoryCount(file: string, bearer: string): Promise<number> {
        let url_ = this.baseUrl + "/edity/Git/RepoHistoryCount?";

        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processRepoHistoryCount(response);
        });
    }

    private processRepoHistoryCount(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: number = null;
                result200 = data === "" ? null : <number>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * The conflicts in the current working directory.
     * @return Success
     */
    conflicts(bearer: string): Promise<ConflictInfo[]> {
        let url_ = this.baseUrl + "/edity/Git/Conflicts";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processConflicts(response);
        });
    }

    private processConflicts(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: ConflictInfo[] = null;
                result200 = data === "" ? null : <ConflictInfo[]>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get the info for a merge for a file.
     * @return Success
     */
    mergeInfo(file: string, bearer: string): Promise<MergeInfo> {
        let url_ = this.baseUrl + "/edity/Git/MergeInfo?";

        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processMergeInfo(response);
        });
    }

    private processMergeInfo(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: MergeInfo = null;
                result200 = data === "" ? null : <MergeInfo>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Ge the history of a file.
     * @file The file to lookup.
     * @page The page to lookup, defaults to 0.
     * @count The number of pages to return, defaults to 25.
     * @return Success
     */
    fileHistory(file: string, page: number, count: number, bearer: string): Promise<History[]> {
        let url_ = this.baseUrl + "/edity/Git/FileHistory?";

        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (count !== undefined)
            url_ += "count=" + encodeURIComponent("" + count) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processFileHistory(response);
        });
    }

    private processFileHistory(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: History[] = null;
                result200 = data === "" ? null : <History[]>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get a particluar file version.
     * @sha The sha to lookup.
     * @file The file.
     * @return Success
     */
    fileVersion(sha: string, file: string, bearer: string): Promise<any> {
        let url_ = this.baseUrl + "/edity/Git/FileVersion?";

        if (sha !== undefined)
            url_ += "sha=" + encodeURIComponent("" + sha) + "&";
        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processFileVersion(response);
        });
    }

    private processFileVersion(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: any = null;
                result200 = data === "" ? null : <any>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Commit the current working directory.
     * @newCommit The new commit object.
     * @return Success
     */
    commit(newCommit: NewCommit, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Git/Commit";

        const content_ = JSON.stringify(newCommit);
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processCommit(response);
        });
    }

    private processCommit(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Pull in changes from the origin repo.
     * @return Success
     */
    pull(bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Git/Pull";

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPull(response);
        });
    }

    private processPull(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Push changes to the origin repo.
     * @return Success
     */
    push(bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Git/Push";

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processPush(response);
        });
    }

    private processPush(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Resolve the conflicts on the file.
     * @file The file to resolve.
     * @return Success
     */
    resolve(file: string, content: FileParameter, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Git/Resolve?";

        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        const content_ = new FormData();
        if (content !== null)
            content_.append("content", content.data, content.fileName ? content.fileName : "content");
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
            }
        }).then((response) => {
            return this.processResolve(response);
        });
    }

    private processResolve(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Revert a file to its unmodified version.
     * @file The file to revert.
     * @return Success
     */
    revert(file: string, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Git/Revert?";

        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processRevert(response);
        });
    }

    private processRevert(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export class PageClient {
    private static jsonMimeType = "application/json";
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    parseResult<T>(response: Response, data: string, jsonParseReviver: (key: string, value: any) => any): T | string {
        var result: T | string;
        var contentHeader = response.headers.get('content-type');
        if (contentHeader && contentHeader.length >= PageClient.jsonMimeType.length && contentHeader.substring(0, PageClient.jsonMimeType.length) === PageClient.jsonMimeType) {
            result = data === "" ? null : <T>JSON.parse(data, jsonParseReviver);
        }
        else {
            result = data === "" ? null : data;
        }
        return result;
    }

    /**
     * Get the current page settings.
     * @page The name of the file to lookup.
     * @return Success
     */
    getSettings(page: string, bearer: string): Promise<PageSettings> {
        let url_ = this.baseUrl + "/edity/Page/GetSettings?";

        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetSettings(response);
        });
    }

    private processGetSettings(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: PageSettings = null;
                result200 = data === "" ? null : <PageSettings>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Update the settings for the page.
     * @page The file who's pages to upload.
     * @settings The page settings to set.
     * @return Success
     */
    updateSettings(page: string, settings: PageSettings, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Page/UpdateSettings?";

        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        const content_ = JSON.stringify(settings);
        return this.http.fetch(url_, {
            body: content_,
            method: "PUT",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processUpdateSettings(response);
        });
    }

    private processUpdateSettings(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "400") {
                    let result400: ModelStateErrorResult = null;
                    result400 = data === "" ? null : <ModelStateErrorResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result400;
                }
                else
                    if (status === "500") {
                        let result500: ExceptionResult = null;
                        result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                        throw result500;
                    }
                    else {
                        throw new Error("error_no_callback_for_the_received_http_status");
                    }
        });
    }

    /**
     * Save a page.
     * @page The file to save.
     * @return Success
     */
    save(page: string, content: FileParameter, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Page/Save?";

        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        const content_ = new FormData();
        if (content !== null)
            content_.append("content", content.data, content.fileName ? content.fileName : "content");
        return this.http.fetch(url_, {
            body: content_,
            method: "PUT",
            headers: {
                "bearer": bearer,
            }
        }).then((response) => {
            return this.processSave(response);
        });
    }

    private processSave(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Delete a page.
     * @page The name of the page to delete.
     * @return Success
     */
    delete(page: string, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Page/Delete?";

        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "DELETE",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processDelete(response);
        });
    }

    private processDelete(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Add an asset to a page.
     * @page The page to add the asset to.
     * @return Success
     */
    addAsset(page: string, upload: FileParameter, bearer: string): Promise<ImageUploadResponse> {
        let url_ = this.baseUrl + "/edity/Page/AddAsset?";

        if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        const content_ = new FormData();
        if (upload !== null)
            content_.append("upload", upload.data, upload.fileName ? upload.fileName : "upload");
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
            }
        }).then((response) => {
            return this.processAddAsset(response);
        });
    }

    private processAddAsset(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: ImageUploadResponse = null;
                result200 = data === "" ? null : <ImageUploadResponse>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export class ShutdownClient {
    private static jsonMimeType = "application/json";
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    parseResult<T>(response: Response, data: string, jsonParseReviver: (key: string, value: any) => any): T | string {
        var result: T | string;
        var contentHeader = response.headers.get('content-type');
        if (contentHeader && contentHeader.length >= ShutdownClient.jsonMimeType.length && contentHeader.substring(0, ShutdownClient.jsonMimeType.length) === ShutdownClient.jsonMimeType) {
            result = data === "" ? null : <T>JSON.parse(data, jsonParseReviver);
        }
        else {
            result = data === "" ? null : data;
        }
        return result;
    }

    /**
     * Stop the Edity McEditface process.
     * @return Success
     */
    shutdown(bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Shutdown/Shutdown";

        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processShutdown(response);
        });
    }

    private processShutdown(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export class TemplateClient {
    private static jsonMimeType = "application/json";
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    parseResult<T>(response: Response, data: string, jsonParseReviver: (key: string, value: any) => any): T | string {
        var result: T | string;
        var contentHeader = response.headers.get('content-type');
        if (contentHeader && contentHeader.length >= TemplateClient.jsonMimeType.length && contentHeader.substring(0, TemplateClient.jsonMimeType.length) === TemplateClient.jsonMimeType) {
            result = data === "" ? null : <T>JSON.parse(data, jsonParseReviver);
        }
        else {
            result = data === "" ? null : data;
        }
        return result;
    }

    /**
     * Get all the templates in the system.
     * @return Success
     */
    listAll(bearer: string): Promise<Template[]> {
        let url_ = this.baseUrl + "/edity/Template/ListAll";

        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processListAll(response);
        });
    }

    private processListAll(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: Template[] = null;
                result200 = data === "" ? null : <Template[]>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Get a single template's content.
     * @return Success
     */
    getContent(file: string, bearer: string): Promise<any> {
        let url_ = this.baseUrl + "/edity/Template/GetContent?";

        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processGetContent(response);
        });
    }

    private processGetContent(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: any = null;
                result200 = data === "" ? null : <any>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export class UploadClient {
    private static jsonMimeType = "application/json";
    private baseUrl: string;
    private http: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> };
    protected jsonParseReviver: (key: string, value: any) => any = undefined;

    constructor(baseUrl?: string, http?: { fetch(url: RequestInfo, init?: RequestInit): Promise<Response> }) {
        this.baseUrl = baseUrl ? baseUrl : "";
        this.http = http ? http : <any>window;
    }

    parseResult<T>(response: Response, data: string, jsonParseReviver: (key: string, value: any) => any): T | string {
        var result: T | string;
        var contentHeader = response.headers.get('content-type');
        if (contentHeader && contentHeader.length >= UploadClient.jsonMimeType.length && contentHeader.substring(0, UploadClient.jsonMimeType.length) === UploadClient.jsonMimeType) {
            result = data === "" ? null : <T>JSON.parse(data, jsonParseReviver);
        }
        else {
            result = data === "" ? null : data;
        }
        return result;
    }

    /**
     * List the files in dir.
     * @dir The directory to list the files under.
     * @return Success
     */
    listFiles(dir: string, bearer: string): Promise<FileList> {
        let url_ = this.baseUrl + "/edity/Upload/ListFiles?";

        if (dir !== undefined)
            url_ += "dir=" + encodeURIComponent("" + dir) + "&";
        return this.http.fetch(url_, {
            method: "GET",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processListFiles(response);
        });
    }

    private processListFiles(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
                let result200: FileList = null;
                result200 = data === "" ? null : <FileList>this.parseResult(response, data, this.jsonParseReviver);
                return result200;
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Uplaod a new file.
     * @file The file name of the uploaded file.
     * @return Success
     */
    upload(file: string, content: FileParameter, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Upload/Upload?";

        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        const content_ = new FormData();
        if (content !== null)
            content_.append("content", content.data, content.fileName ? content.fileName : "content");
        return this.http.fetch(url_, {
            body: content_,
            method: "POST",
            headers: {
                "bearer": bearer,
            }
        }).then((response) => {
            return this.processUpload(response);
        });
    }

    private processUpload(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }

    /**
     * Delete a file.
     * @file The file to delete.
     * @return Success
     */
    delete(file: string, bearer: string): Promise<void> {
        let url_ = this.baseUrl + "/edity/Upload/Delete?";

        if (file !== undefined)
            url_ += "file=" + encodeURIComponent("" + file) + "&";
        const content_ = "";
        return this.http.fetch(url_, {
            body: content_,
            method: "DELETE",
            headers: {
                "bearer": bearer,
                "Content-Type": "application/json; charset=UTF-8"
            }
        }).then((response) => {
            return this.processDelete(response);
        });
    }

    private processDelete(response: Response) {
        return response.text().then((data) => {
            const status = response.status.toString();

            if (status === "200") {
            }
            else
                if (status === "500") {
                    let result500: ExceptionResult = null;
                    result500 = data === "" ? null : <ExceptionResult>this.parseResult(response, data, this.jsonParseReviver);
                    throw result500;
                }
                else {
                    throw new Error("error_no_callback_for_the_received_http_status");
                }
        });
    }
}

export interface CompilerStatus {
    readonly behindBy: number;
    readonly behindHistory: any;
}

export interface ExceptionResult {
    exception: any;
    message: string;
}

export interface CompilerResult {
    elapsedSeconds: number;
}

export interface UncommittedChange {
    readonly filePath: string;
    readonly state: UncommittedChangeState;
}

export interface SyncInfo {
    aheadBy: number;
    behindBy: number;
    aheadHistory: History[];
    behindHistory: History[];
    hasUncomittedChanges: boolean;
}

export interface History {
    readonly message: string;
    readonly sha: string;
    readonly name: string;
    readonly email: string;
    readonly when: Date;
}

export interface DiffInfo {
    original: string;
    changed: string;
}

export interface ConflictInfo {
    readonly filePath: string;
}

export interface MergeInfo {
    merged: string;
    theirs: string;
    mine: string;
}

export interface NewCommit {
    message: string;
}

export interface PageSettings {
    title: string;
}

export interface ModelStateErrorResult {
    errors: { [key: string]: string; };
    message: string;
}

export interface ImageUploadResponse {
    /** Set to 1 for uploaded or 0 for not uploaded */
    uploaded: number;
    /** The name of the saved file */
    fileName: string;
    /** The url to the saved file */
    url: string;
    /** A message to display */
    message: string;
}

export interface Template {
    path: string;
}

/** A list of files in a directory. */
export interface FileList {
    /** The directories inside this directory. */
    directories: string[];
    /** The files inside this directory. */
    files: string[];
    /** The path that this file list represents. */
    path: string;
}

export enum UncommittedChangeState {
    Nonexistent = <any>"Nonexistent",
    Unaltered = <any>"Unaltered",
    Added = <any>"Added",
    Removed = <any>"Removed",
    Renamed = <any>"Renamed",
    Modified = <any>"Modified",
    Unreadable = <any>"Unreadable",
    Ignored = <any>"Ignored",
    Conflicted = <any>"Conflicted",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export function addServices(services: di.ServiceCollection){
    services.tryAddShared(CompileClient, s => {
        var fetcher = s.getRequiredService(Fetcher);
        var shim = s.getRequiredService(IBaseUrlInjector);
        return new CompileClient(shim.BaseUrl, fetcher);
    });

    services.tryAddShared(GitClient, s => {
        var fetcher = s.getRequiredService(Fetcher);
        var shim = s.getRequiredService(IBaseUrlInjector);
        return new GitClient(shim.BaseUrl, fetcher);
    });

    services.tryAddShared(PageClient, s => {
        var fetcher = s.getRequiredService(Fetcher);
        var shim = s.getRequiredService(IBaseUrlInjector);
        return new PageClient(shim.BaseUrl, fetcher);
    });

    services.tryAddShared(UploadClient, s => {
        var fetcher = s.getRequiredService(Fetcher);
        var shim = s.getRequiredService(IBaseUrlInjector);
        return new UploadClient(shim.BaseUrl, fetcher);
    });
}